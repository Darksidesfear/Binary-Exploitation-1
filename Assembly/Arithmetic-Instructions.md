```
Instruction <destination>, <source>  -> Intel Syntax

Instruction <source>, <destination>  -> AT&T Syntax
```

PUSH
------
places its operand onto the top of the stack (decrements ESP by 4).
```
push <reg32, mem>
```

POP
------
it removes the 4-byte data element from the top of the stack.
```
pop <reg32, mem>
```
	
MOV
------
copies the data item referred to by its second operand (i.e. register contents, memory contents, or a constant value) into the location referred to by its first operand.
```
mov <reg, mem>, <reg, mem>
```
	
LEA 
------
places the address specified by its second operand into the register specified by its first operand.
```
lea <mem>, <reg32>
```

ADD
-------
sum its two operands and then storing the result in its first operand.
```	
add <reg, mem>, <reg, mem>
```

SUB
-------
it's completely unlike the add Instruction
```
sub <reg, mem>, <reg, mem>
```
	
CALL
--------
used to call a subroutine. Subroutines are often used to perform tasks that need to be performed frequently. in other words, call used when it wants to another function and then return after that function to the next instruction after call.

**call instruction first saves (push) the current instruction into the stack (to return after the function done) and then jumps into that function and then it returns into the saved instruction address.
```
call <address>
```

RET
--------
implements a subroutine return mechanism. it first gets and removes the return address from the stack (pop) and then it jumps to the retrieved code location.
```	
ret
```

CMP
--------
Compare the values of the two specified operands, setting the condition codes in the machine status word appropriately. the result will be used in the next instruction 
```
cmp arg2, arg1
```

JMP
--------
Transfers program control flow to the instruction at the memory location indicated by the operand.
```	
jmp <address>
(
	je <label> (jump when equal) *(jump if ZF=1)*
	jne <label> (jump when not equal) *(jump if ZF=0)*
	jz <label> (jump when last result was zero) *(Same as je)*
	jg <label> (jump when dst > src)
	jge <label> (jump when dst ≥ src)
	jl <label> (jump when dst < src) *(jump if CF=1 & ZF=0)*
	jle <label> (jump when dst ≤ src) *(jump if ZF=1 or SF<>OF)*
	jnbe <label> (jump when dst > src)
)
```
**CMP Always Comes with JMP Instruction
```
cmp ebx, eax
je address
```
	

Example of a disassembly of a ELF 32bit Program. (Stack0 From ProtoStarLab)
---------------------------------------------------------------------------
```

0x080483f4 <main+0>:    push   ebp
0x080483f5 <main+1>:    mov    ebp,esp
0x080483f7 <main+3>:    and    esp,0xfffffff0
0x080483fa <main+6>:    sub    esp,0x60
0x080483fd <main+9>:    mov    DWORD PTR [esp+0x5c],0x0
0x08048405 <main+17>:   lea    eax,[esp+0x1c]
0x08048409 <main+21>:   mov    DWORD PTR [esp],eax
0x0804840c <main+24>:   call   0x804830c <gets@plt>
0x08048411 <main+29>:   mov    eax,DWORD PTR [esp+0x5c]
0x08048415 <main+33>:   test   eax,eax
0x08048417 <main+35>:   je     0x8048427 <main+51>
0x08048419 <main+37>:   mov    DWORD PTR [esp],0x8048500
0x08048420 <main+44>:   call   0x804832c <puts@plt>
0x08048425 <main+49>:   jmp    0x8048433 <main+63>
0x08048427 <main+51>:   mov    DWORD PTR [esp],0x8048529
0x0804842e <main+58>:   call   0x804832c <puts@plt>
0x08048433 <main+63>:   leave
0x08048434 <main+64>:   ret
```
