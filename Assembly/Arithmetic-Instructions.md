Instruction <destination>, <source>  -> Intel Syntax
Instruction <source>, <destination>  -> AT&T Syntax


push -> places its operand onto the top of the stack (decrements ESP by 4).
push <reg32, mem>

pop -> it removes the 4-byte data element from the top of the stack.
pop <reg32, mem>

mov -> copies the data item referred to by its second operand (i.e. register contents, memory contents, or a constant value) into the location referred to by its first operand.
mov <reg, mem>, <reg, mem>

lea -> places the address specified by its second operand into the register specified by its first operand.
lea <mem>, <reg32>

add -> sum its two operands and then storing the result in its first operand.
add <reg, mem>, <reg, mem>

sub -> it's completely unlike the add Instruction
sub <reg, mem>, <reg, mem>

call -> used to call a subroutine. Subroutines are often used to perform tasks that need to be performed frequently. in other words, call used when it wants to another function and then return after that function to the next instruction after call.
*call instruction first saves (push) the current instruction into the stack (to return after the function done) and then jumps into that function and then it returns into the saved instruction address.
call <address>

ret -> implements a subroutine return mechanism. it first gets and removes the return address from the stack (pop) and then it jumps to the retrieved code location.
ret

jmp -> Transfers program control flow to the instruction at the memory location indicated by the operand.
jmp <address>

cmp -> Compare the values of the two specified operands, setting the condition codes in the machine status word appropriately. the result will be used in the next instruction 
(
	je <label> (jump when equal)
	jne <label> (jump when not equal)
	jz <label> (jump when last result was zero)
	jg <label> (jump when greater than)
	jge <label> (jump when greater than or equal to)
	jl <label> (jump when less than)
	jle <label> (jump when less than or equal to)
)
cmp ebx, eax
jle done

-------------------------------------------------------------------------------------------------

^PROLOGUE^
push  ebp         ; Save the stack-frame base pointer (of the calling function).
mov   ebp, esp    ; Set the stack-frame base pointer to be the current location on the stack.
sub   esp, N      ; Grow the stack by N bytes to reserve space for local variables

^EPILOGUE^
mov   esp, ebp    ; Put the stack pointer back where it was when this function was called.
pop   ebp         ; Restore the calling function's stack frame.
ret               ; Return to the calling function.

-------------------------------------------------------------------------------------------------

Example of a disassembly of a ELF 32bit Program. (Stack0 From ProtoStarLab)
disassemble of /opt/protostar/bin/stack0

0x080483f4 <main+0>:    push   ebp
0x080483f5 <main+1>:    mov    ebp,esp
0x080483f7 <main+3>:    and    esp,0xfffffff0
0x080483fa <main+6>:    sub    esp,0x60
0x080483fd <main+9>:    mov    DWORD PTR [esp+0x5c],0x0
0x08048405 <main+17>:   lea    eax,[esp+0x1c]
0x08048409 <main+21>:   mov    DWORD PTR [esp],eax
0x0804840c <main+24>:   call   0x804830c <gets@plt>
0x08048411 <main+29>:   mov    eax,DWORD PTR [esp+0x5c]
0x08048415 <main+33>:   test   eax,eax
0x08048417 <main+35>:   je     0x8048427 <main+51>
0x08048419 <main+37>:   mov    DWORD PTR [esp],0x8048500
0x08048420 <main+44>:   call   0x804832c <puts@plt>
0x08048425 <main+49>:   jmp    0x8048433 <main+63>
0x08048427 <main+51>:   mov    DWORD PTR [esp],0x8048529
0x0804842e <main+58>:   call   0x804832c <puts@plt>
0x08048433 <main+63>:   leave
0x08048434 <main+64>:   ret
